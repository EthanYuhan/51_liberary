C51 COMPILER V9.60.7.0   MAIN                                                              05/18/2023 17:05:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\OBJ\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\USER;..\README;..\HARDWARE\lcd
                    -12864;..\SYSTEM\delay;..\SYSTEM\sys;..\HARDWARE\key;..\HARDWARE\motor;..\HARDWARE\timer;..\HARDWARE\ad;..\HARDWARE\ds130
                    -2;..\HARDWARE\interrupt;..\HARDWARE\dht11) DEBUG OBJECTEXTEND TABS(2) OBJECT(..\OBJ\main.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include <intrins.h>
   3          #include <stdio.h>
   4          #include "string.h"
   5          #include "sys.h"
   6          #include "lcd12864.h"
   7          #include "key.h"
   8          #include "timer.h"
   9          #include "ad.h"
  10          #include "ds1302.h"
  11          #include "dht11.h"
  12          
  13          
  14          
  15          u8 code CharCodeLine1[]="CZCJJQ";       //第一行显示字符
  16          u8 code CharCodeLine2[]="0302";         //第二行显示字符
  17          u8 code MileValue[]="mile：       km";  //显示行驶里程
  18          u8 code CostValue[]="cost：     yuan";  //显示应收取费用
  19          u8 code WaiteTimeValue[]="delay ：    min"; //显示应收取费用
  20          
  21          u8  StartDrive = 0 ;  //0-停车服务结束 1-开始服务计价中 2-静止等待状态
  22          u16 MileNum = 0;    //里程计数
  23          u16 CostNum = 0;      //应收费用计数
  24          u16 WaiteTimeNum = 0; //等待时间
  25          u16 StartPrice = 6;   //起步价 默认 6
  26          u8  TimeNum = 1;      //时段1/2 默认为1
  27          u16 ad;               //ADC采样值
  28          u8  MoterSpeed =8;    //通过定时器2控制步进电机转速
  29          u8  AdcFlag = 0 ;     //adc采样标志
  30          u16 InterruptCount = 0 ;  //码盘中断计数
  31          
  32          
  33          extern u8 KeyCode;      //按键键值
  34          extern u16 TimerCount ; //定时器计数
  35          extern u8 PulseNum;     //脉冲计数
  36          extern u16 WaiteTimeCount; //静止状态等待时间计数
  37          
  38          
  39          void IO_init(void)  //IO口初始化
  40          {
  41   1        //IO配置为准双向IO口 
  42   1        P0M0 = 0X00;  P0M1 = 0X00;  
  43   1        P1M0 = 0X00;  P1M1 = 0X00;
  44   1        P2M0 = 0X00;  P2M1 = 0X00;
  45   1        P3M0 = 0X00;  P3M1 = 0X00;
  46   1        P4M0 = 0X00;  P4M1 = 0X00;    
  47   1        P5M0 = 0X00;  P5M1 = 0X00;    
  48   1        P6M0 = 0X00;  P6M1 = 0X00;    
  49   1        P7M0 = 0X00;  P7M1 = 0X00;  
  50   1        
  51   1        //设置推挽输出
  52   1        P2M1 &= ~(1<<2),P2M0 |=  (1<<2); //12864LCD设置
  53   1        P2M1 &= ~(1<<1),P2M0 |=  (1<<1); 
C51 COMPILER V9.60.7.0   MAIN                                                              05/18/2023 17:05:13 PAGE 2   

  54   1        P2M1 &= ~(1<<0),P2M0 |=  (1<<0); 
  55   1        P1M1 &= ~(1<<3),P1M0 |=  (1<<3); //步进电机
  56   1        P1M1 &= ~(1<<4),P1M0 |=  (1<<4); 
  57   1        P1M1 &= ~(1<<1),P1M0 |=  (1<<1); 
  58   1        P1M1 &= ~(1<<2),P1M0 |=  (1<<2); 
  59   1        P5M1 &= ~(1<<5),P5M0 |=  (1<<5); //蜂鸣器
  60   1        P5M1 &= ~(1<<2),P5M0 |=  (1<<2); //继电器
  61   1      }
  62          
  63          
  64          void Roll(void)  //卷动显示两行字
  65          { 
  66   1        uchar i;  
  67   1        
  68   1        //为显示上半屏第一行字符做准备，地址0xa0  
  69   1        //详细参考文章：https://wenku.baidu.com/view/375ec764cc22bcd127ff0c9a.html  
  70   1        LCD12864_WriteCmd(0xa0);  
  71   1        while(CharCodeLine1[i]!='\0')
  72   1        {
  73   2          LCD12864_WriteData(CharCodeLine1[i]);
  74   2          i++;
  75   2        }
  76   1        i=0;
  77   1        //为显示上半屏第二行字符做准备，地址0xb0    
  78   1        LCD12864_WriteCmd(0xb0);    
  79   1        while(CharCodeLine2[i]!='\0')
  80   1        {
  81   2          LCD12864_WriteData(CharCodeLine2[i]);
  82   2          i++;
  83   2        }
  84   1        
  85   1          for(i=0;i<33;i++)    //上半屏卷动显示
  86   1        {
  87   2            LCD12864_VerticalRoll(i);
  88   2            Delay100ms();  //每行高16个像素，两行32像素，0.1秒卷动1像素，两行字显示结束共需要3.2秒
  89   2        }
  90   1        LCD12864_WriteCmd(0x30); //恢复基本指令集
  91   1      }
  92          
  93          
  94          
  95          
  96          
  97          
  98          void main(void)  //主函数
  99          { 
 100   1        u8 i; 
 101   1        u8 temp;
 102   1        
 103   1        UpdateTemp();
 104   1      
 105   1        IO_init();         //IO口初始化   
 106   1          LCD12864_Init();         //12864液晶初始化  
 107   1        Give(0x00);        //停止步进电机
 108   1        
 109   1        Roll();                //卷动显示两行字 
 110   1        Delay100ms(); 
 111   1        
 112   1        LCD12864_WriteCmd(0x01); //清除LCD12864的显示内容 
 113   1        LCD12864_SetWindow(0,0); //第1行显示行驶里程
 114   1        while(MileValue[i]!='\0')
 115   1        {
C51 COMPILER V9.60.7.0   MAIN                                                              05/18/2023 17:05:13 PAGE 3   

 116   2          LCD12864_WriteData(MileValue[i]);
 117   2          i++;
 118   2        }
 119   1        i=0;  
 120   1        LCD12864_SetWindow(1,0); //第2行显示应收取费用
 121   1        while(CostValue[i]!='\0')  
 122   1        {
 123   2          LCD12864_WriteData(CostValue[i]);
 124   2          i++;
 125   2        }
 126   1        i=0;
 127   1          
 128   1        while(1)  //主循环
 129   1        { 
 130   2          IO_KeyScan();   //按键扫描 检测按键 
 131   2          
 132   2          ds1302_scan();  //RTC时间显示 时分
 133   2          delay1ms(10);   //延时
 134   2           
 135   2          if(KeyCode ==1) //S1按下（矩阵键盘第一键）
 136   2          {
 137   3            KeyCode=0;        
 138   3            if(StartDrive==0)  //0-服务结束状态(停车)
 139   3            {
 140   4              StartDrive=1;
 141   4              PulseNum =0 ;
 142   4              TimerCount = 0;       
 143   4              InterruptCount = 0; //里程计数清零
 144   4              WaiteTimeCount = 0; //静止等待时间清零
 145   4              MileNum = 0;    //里程计数
 146   4              CostNum = 0;    //应收费用计数
 147   4              WaiteTimeNum = 0;   //等待时间
 148   4              
 149   4              Timer2Init(); //定时器2初始化       
 150   4              IE2 |=0x04;   //开定时器2中断--定时器控制步进电机转动
 151   4              IT1 =1;     //设置INT1的中断类型（1：仅下降沿 0：上升沿货下降沿）
 152   4              EX1 =1;       //使能INT1中断    
 153   4              EA  =1;       //开总中断 
 154   4            }
 155   3            else if(StartDrive==1) //1-开始服务计价中状态
 156   3            {
 157   4              StartDrive=0;//停止服务停止计价       
 158   4              IE2 &=~0x04; //关定时器2中断
 159   4              EA  =0;      //关总中断           
 160   4              Give(0x00);  //停止步进电机   
 161   4            }   
 162   3          }
 163   2          else if(KeyCode ==2) //S2按下
 164   2          {
 165   3            KeyCode=0;      
 166   3            if(StartDrive==1) 
 167   3            {
 168   4              StartDrive=2; //进入服务结束状态(停车)      
 169   4              IE2 &=~0x04;  //关定时器2中断               
 170   4              Give(0x00);   //停止步进电机  
 171   4                
 172   4              Timer0Init(); //定时器0初始化
 173   4              ET0 =1;     //使能定时器中断  
 174   4              TR0 =1;     //定时器0开始计时--计算等待时间
 175   4              EA  =1;       //开总中断        
 176   4      
 177   4              LCD12864_SetWindow(2,0); //第3行显示等待时间
C51 COMPILER V9.60.7.0   MAIN                                                              05/18/2023 17:05:13 PAGE 4   

 178   4              while(WaiteTimeValue[i]!='\0')  
 179   4              {
 180   5                LCD12864_WriteData(WaiteTimeValue[i]);
 181   5                i++;
 182   5              }
 183   4              i=0;      
 184   4            }
 185   3            else if(StartDrive==2) 
 186   3            {
 187   4              StartDrive=1; //退出静止状态        
 188   4              ET0 =0;     //关 定时器中断 
 189   4                TR0 =0;     //关 定时器0开始计时        
 190   4              IE2 |=0x04;     //开定时器2中断--定时器控制步进电机转动       
 191   4      
 192   4              LCD12864_SetWindow(2,4);//第3行----显示等待时间
 193   4              WaiteTimeNum=WaiteTimeCount/20; //分钟数，用1秒代替5分钟 
 194   4              LCD12864_WriteData(WaiteTimeNum/1000%10+0x30);//千位
 195   4              LCD12864_WriteData(WaiteTimeNum/100%10+0x30);       
 196   4              LCD12864_WriteData(WaiteTimeNum/10%10+0x30);
 197   4              LCD12864_WriteData(WaiteTimeNum%10+0x30);
 198   4            }
 199   3          }
 200   2          else if(KeyCode ==3) //S3按下切换时段
 201   2          {
 202   3            KeyCode=0;      
 203   3            if(TimeNum==1)
 204   3            {
 205   4              TimeNum=2;
 206   4              StartPrice = 7;
 207   4            }
 208   3            else
 209   3            {
 210   4              TimeNum=1;
 211   4              StartPrice = 6;
 212   4            }
 213   3          }
 214   2          
 215   2          else if(KeyCode ==13) //RTC时间调整  时加一
 216   2          {
 217   3            KeyCode=0;  
 218   3                temp = bcd_read(0x85);//时        
 219   3            if(temp==23) temp=0;
 220   3            else temp=temp+1;
 221   3            temp = temp/10*16+temp%10;
 222   3            Write_Ds1302(0x8E,0X00);   //写使能 
 223   3            Write_Ds1302(0x84,temp);  
 224   3            Write_Ds1302(0x8E,0x80);   //写禁止
 225   3          }
 226   2          else if(KeyCode ==14) //RTC时间调整 时减一
 227   2          {
 228   3            KeyCode=0;
 229   3            temp = bcd_read(0x85);//时      
 230   3            if(temp==0) temp=23;
 231   3            else temp=temp-1;
 232   3            temp = temp/10*16+temp%10;
 233   3            Write_Ds1302(0x8E,0X00);   //写使能 
 234   3            Write_Ds1302(0x84,temp);  
 235   3            Write_Ds1302(0x8E,0x80);   //写禁止
 236   3          }
 237   2          else if(KeyCode ==15) //RTC时间调整  分加一
 238   2          {
 239   3            KeyCode=0;
C51 COMPILER V9.60.7.0   MAIN                                                              05/18/2023 17:05:13 PAGE 5   

 240   3            temp = bcd_read(0x83);//分        
 241   3            if(temp==59) temp=0;
 242   3            else temp=temp+1;
 243   3            temp = temp/10*16+temp%10;
 244   3            Write_Ds1302(0x8E,0X00);   //写使能 
 245   3            Write_Ds1302(0x82,temp);  
 246   3            Write_Ds1302(0x8E,0x80);   //写禁止     
 247   3          }
 248   2          else if(KeyCode ==16) //RTC时间调整 分减一
 249   2          {
 250   3            KeyCode=0;
 251   3            temp = bcd_read(0x83);//分      
 252   3            if(temp==0) temp=59;
 253   3            else temp=temp-1;
 254   3            temp = temp/10*16+temp%10;
 255   3            Write_Ds1302(0x8E,0X00);   //写使能 
 256   3            Write_Ds1302(0x82,temp);  
 257   3            Write_Ds1302(0x8E,0x80);   //写禁止
 258   3          }
 259   2          
 260   2          
 261   2          
 262   2          if(StartDrive==1)  //开始计价 并显示
 263   2          {
 264   3            
 265   3            if(AdcFlag > 0) //ADC采样一次
 266   3            {
 267   4              AdcFlag = 0;
 268   4              ad=GetADCResult(0);        //采集AD 值为300-1020      
 269   4                MoterSpeed =(float)ad*0.05-13; //4-40范围
 270   4            }
 271   3              
 272   3      
 273   3      #if DRIVING_SIMULATION  
                    
                    MileNum=PulseNum*4;     //定时脉冲情况下1秒行驶4km
                    LCD12864_SetWindow(0,3);//第1行 显示里程
                    LCD12864_WriteData(MileNum/10000%10+0x30);
                    LCD12864_WriteData(MileNum/1000%10+0x30); //千位
                    LCD12864_WriteData(MileNum/100%10+0x30);      
                    LCD12864_WriteData(MileNum/10%10+0x30);     
                    LCD12864_WriteData(MileNum%10+0x30);
                    
                    CostNum=(MileNum-3)*12+60;  //因为1秒即运行4km，已经超过起步价，此价格为10倍真实价格
                    LCD12864_SetWindow(1,3);    //第2行 显示应收取费用  
                    LCD12864_WriteData(CostNum/1000%10+0x30);//千位
                    LCD12864_WriteData(CostNum/100%10+0x30);      
                    LCD12864_WriteData(CostNum/10%10+0x30); 
                    LCD12864_WriteData('.');
                    LCD12864_WriteData(CostNum%10+0x30);
                        
              #else                 //码盘一圈20格，1圈1米，为演示方便乘1000倍，即1圈1km 1格0.05km
 292   3            MileNum=InterruptCount*5; //步进电机码盘计算，为显示小数点 乘100倍                    
 293   3            LCD12864_SetWindow(0,3);  //第1行显示里程
 294   3            LCD12864_WriteData(MileNum/10000%10+0x30);
 295   3            LCD12864_WriteData(MileNum/1000%10+0x30);//千位
 296   3            LCD12864_WriteData(MileNum/100%10+0x30);  
 297   3            LCD12864_WriteData('.');                 //两位小数点
 298   3            LCD12864_WriteData(MileNum/10%10+0x30);     
 299   3            LCD12864_WriteData(MileNum%10+0x30);
 300   3            
 301   3            if(MileNum<= 300)  //乘100倍，起步价区间3km
C51 COMPILER V9.60.7.0   MAIN                                                              05/18/2023 17:05:13 PAGE 6   

 302   3            {
 303   4              CostNum = (StartPrice*100) +(WaiteTimeNum*20) ; //真实价格100倍
 304   4            }
 305   3            else              //超出起步价区间
 306   3            {
 307   4                            //真实价格100倍
 308   4              CostNum =(float)((MileNum-300)*1.2)+(StartPrice*100)+(WaiteTimeNum*20) ;
 309   4            }     
 310   3            LCD12864_SetWindow(1,3);//第2行 显示应收取费用    
 311   3            LCD12864_WriteData(CostNum/10000%10+0x30);
 312   3            LCD12864_WriteData(CostNum/1000%10+0x30);//千位
 313   3            LCD12864_WriteData(CostNum/100%10+0x30);  
 314   3            LCD12864_WriteData('.');      
 315   3            LCD12864_WriteData(CostNum/10%10+0x30); 
 316   3      #endif
 317   3      
 318   3          }
 319   2          else if(StartDrive==2) //静止等待状态 循环显示等待时间
 320   2          {
 321   3            LCD12864_SetWindow(2,4);        //第3行显示等待时间
 322   3            WaiteTimeNum=WaiteTimeCount/20; //用1秒代替5分钟
 323   3            LCD12864_WriteData(WaiteTimeNum/1000%10+0x30);//千位
 324   3            LCD12864_WriteData(WaiteTimeNum/100%10+0x30);       
 325   3            LCD12864_WriteData(WaiteTimeNum/10%10+0x30);
 326   3            LCD12864_WriteData(WaiteTimeNum%10+0x30);
 327   3            
 328   3            
 329   3            //显示总金额
 330   3            if(MileNum<= 300)  //乘100倍  起步价区间3km
 331   3            {
 332   4              CostNum = (StartPrice*100) +(WaiteTimeNum*20) ; //真实价格100倍
 333   4            }
 334   3            else              //超出起步价区间
 335   3            {
 336   4                            //真实价格100倍
 337   4              CostNum =(float)((MileNum-300)*1.2)+(StartPrice*100)+(WaiteTimeNum*20) ;
 338   4            }     
 339   3            LCD12864_SetWindow(1,3);//第2行 显示应收取费用    
 340   3            LCD12864_WriteData(CostNum/10000%10+0x30);
 341   3            LCD12864_WriteData(CostNum/1000%10+0x30);//千位
 342   3            LCD12864_WriteData(CostNum/100%10+0x30);  
 343   3            LCD12864_WriteData('.');      
 344   3            LCD12864_WriteData(CostNum/10%10+0x30); 
 345   3          }
 346   2        }
 347   1      }
 348          
 349          
 350          
 351          void exint0()  interrupt 2 //外部中断1中断
 352          {
 353   1        InterruptCount ++ ;    //码盘一圈20格
 354   1      }
 355          
 356          
 357          
 358          
 359          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1653    ----
C51 COMPILER V9.60.7.0   MAIN                                                              05/18/2023 17:05:13 PAGE 7   

   CONSTANT SIZE    =     60    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
