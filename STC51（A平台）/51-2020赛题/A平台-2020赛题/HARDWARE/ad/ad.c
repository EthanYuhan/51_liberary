#include "stc15f2k60s2.h"
#include "sys.h"
#include "intrins.h" 
#include "ad.h"
 
                                   

/*Define ADC operation const for ADC_CONTR*/ 
#define ADC_POWER   0x80            //ADC power control bit 
#define ADC_FLAG    0x10            //ADC complete flag      模数转换结束标志位 
#define ADC_START   0x08            //ADC start control bit  模数转换启动控制位 


//转换速度控制位SPEED0和SPEED1，共四种状态，对应四种转换速度 
#define ADC_SPEEDLL 0x00            //540 clocks  
#define ADC_SPEEDL  0x20            //360 clocks 
#define ADC_SPEEDH  0x40            //180 clocks 
#define ADC_SPEEDHH 0x60            //90 clocks 



/*---------------------------- 
Get ADC result 
----------------------------*/ 
u16 GetADCResult(u8 ch)                                // 
{ 
    u16 Vo;
    P1ASF = 0x01;                                        //选择P1口的哪一口 这里的口和ch要对应才能达到选择该口
    ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ch | ADC_START;//0x00|0x00|ch|0x08:选择A/D输入通道，开始A/D转换 
                                                         // 这么用语句的主要原因就是不能位寻址
                                                         //   通道选择在后3位所以直接用一个整数表示ch
                                                         //例如ch=6 那么对应的后三位就是110           
    _nop_();                             //Must wait before inquiry ， 
    _nop_();                             //设置ADC_CONTR寄存器后需加4个CPU时钟周期的延时，才能保证值被写入ADC_CONTR寄存器 
    _nop_(); 
    _nop_(); 
    while (!(ADC_CONTR & ADC_FLAG));     //Wait complete flag 

   ADC_CONTR &= ~ADC_FLAG;               //Close ADC 将标志位清零等待下次硬件置1
                                         //也可以写成 ADC_CONTR= ADC_CONTR & ( ~ADC_FLAG)
   Vo=(ADC_RES<<2)+ADC_RESL; 			 //打开10位AD采集功能   如果用8位AD Vo=ADC_RESL 即可
                                         //10位AD采集 即2的10次方 满值为1024 这里用1024表示5伏的电压 
										 //8位AD采集 即 2的8次方  满值为256  用256表示5伏
    return Vo; 
} 

/*************************************************************************************/


